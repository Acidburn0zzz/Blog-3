/**
 * generated by Scrooge ${project.version}
 */
package ca.stevenskelton.thrift.testservice

import com.twitter.scrooge.{
  ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3}
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-09-20T13:33:14.999-0400")
trait TestApi[+MM[_]] extends ThriftService {
  
  def wNoDelay(id: Int): MM[SampleStruct]
  
  def w100msDelay(id: Int): MM[SampleStruct]
  
  def w200msDelay(id: Int): MM[SampleStruct]
  
  def w1sDelay(id: Int): MM[SampleStruct]
}


object TestApi {
  
  object wNoDelay$args extends ThriftStructCodec3[wNoDelay$args] {
    val Struct = new TStruct("wNoDelay_args")
    val IdField = new TField("id", TType.I32, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: wNoDelay$args) {
    }
  
    override def encode(_item: wNoDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): wNoDelay$args = Immutable.decode(_iprot)
  
    def apply(
      id: Int
    ): wNoDelay$args = new Immutable(
      id
    )
  
    def unapply(_item: wNoDelay$args): Option[Int] = Some(_item.id)
  
    object Immutable extends ThriftStructCodec3[wNoDelay$args] {
      override def encode(_item: wNoDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): wNoDelay$args = {
        var id: Int = 0
        var _got_id = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* id */
                _field.`type` match {
                  case TType.I32 => {
                    id = {
                      _iprot.readI32()
                    }
                    _got_id = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          id
        )
      }
    }
  
    /**
     * The default read-only implementation of wNoDelay$args.  You typically should not need to
     * directly reference this class; instead, use the wNoDelay$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val id: Int
    ) extends wNoDelay$args
  
  }
  
  trait wNoDelay$args extends ThriftStruct
    with Product1[Int]
    with java.io.Serializable
  {
    import wNoDelay$args._
  
  
    def id: Int
  
    def _1 = id
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): wNoDelay$args =
      _fieldId match {
        case 1 => copy(id = 0)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      wNoDelay$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val id_item = id
        _oprot.writeFieldBegin(IdField)
        _oprot.writeI32(id_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      id: Int = this.id
    ): wNoDelay$args =
      new Immutable(
        id
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[wNoDelay$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => id
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "wNoDelay$args"
  }
  
  object wNoDelay$result extends ThriftStructCodec3[wNoDelay$result] {
    val Struct = new TStruct("wNoDelay_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NotFoundExceptionField = new TField("notFoundException", TType.STRUCT, 1)
    val DisabledExceptionField = new TField("disabledException", TType.STRUCT, 2)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: wNoDelay$result) {
    }
  
    override def encode(_item: wNoDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): wNoDelay$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[SampleStruct] = None,
      notFoundException: Option[NotFoundException] = None,
      disabledException: Option[DisabledException] = None
    ): wNoDelay$result = new Immutable(
      success,
      notFoundException,
      disabledException
    )
  
    def unapply(_item: wNoDelay$result): Option[Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec3[wNoDelay$result] {
      override def encode(_item: wNoDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): wNoDelay$result = {
        var success: SampleStruct = null
        var _got_success = false
        var notFoundException: NotFoundException = null
        var _got_notFoundException = false
        var disabledException: DisabledException = null
        var _got_disabledException = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      SampleStruct.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* notFoundException */
                _field.`type` match {
                  case TType.STRUCT => {
                    notFoundException = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_notFoundException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* disabledException */
                _field.`type` match {
                  case TType.STRUCT => {
                    disabledException = {
                      DisabledException.decode(_iprot)
                    }
                    _got_disabledException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_notFoundException) Some(notFoundException) else None,
          if (_got_disabledException) Some(disabledException) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of wNoDelay$result.  You typically should not need to
     * directly reference this class; instead, use the wNoDelay$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[SampleStruct] = None,
      val notFoundException: Option[NotFoundException] = None,
      val disabledException: Option[DisabledException] = None
    ) extends wNoDelay$result
  
  }
  
  trait wNoDelay$result extends ThriftStruct
    with Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]
    with java.io.Serializable
  {
    import wNoDelay$result._
  
  
    def success: Option[SampleStruct]
    def notFoundException: Option[NotFoundException]
    def disabledException: Option[DisabledException]
  
    def _1 = success
    def _2 = notFoundException
    def _3 = disabledException
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): wNoDelay$result =
      _fieldId match {
        case 0 => copy(success = None)
        case 1 => copy(notFoundException = None)
        case 2 => copy(disabledException = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      wNoDelay$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (notFoundException.isDefined) {
        val notFoundException_item = notFoundException.get
        _oprot.writeFieldBegin(NotFoundExceptionField)
        notFoundException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (disabledException.isDefined) {
        val disabledException_item = disabledException.get
        _oprot.writeFieldBegin(DisabledExceptionField)
        disabledException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[SampleStruct] = this.success, 
      notFoundException: Option[NotFoundException] = this.notFoundException, 
      disabledException: Option[DisabledException] = this.disabledException
    ): wNoDelay$result =
      new Immutable(
        success,
        notFoundException,
        disabledException
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[wNoDelay$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => notFoundException
      case 2 => disabledException
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "wNoDelay$result"
  }
  
  object w100msDelay$args extends ThriftStructCodec3[w100msDelay$args] {
    val Struct = new TStruct("w100msDelay_args")
    val IdField = new TField("id", TType.I32, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: w100msDelay$args) {
    }
  
    override def encode(_item: w100msDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): w100msDelay$args = Immutable.decode(_iprot)
  
    def apply(
      id: Int
    ): w100msDelay$args = new Immutable(
      id
    )
  
    def unapply(_item: w100msDelay$args): Option[Int] = Some(_item.id)
  
    object Immutable extends ThriftStructCodec3[w100msDelay$args] {
      override def encode(_item: w100msDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): w100msDelay$args = {
        var id: Int = 0
        var _got_id = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* id */
                _field.`type` match {
                  case TType.I32 => {
                    id = {
                      _iprot.readI32()
                    }
                    _got_id = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          id
        )
      }
    }
  
    /**
     * The default read-only implementation of w100msDelay$args.  You typically should not need to
     * directly reference this class; instead, use the w100msDelay$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val id: Int
    ) extends w100msDelay$args
  
  }
  
  trait w100msDelay$args extends ThriftStruct
    with Product1[Int]
    with java.io.Serializable
  {
    import w100msDelay$args._
  
  
    def id: Int
  
    def _1 = id
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): w100msDelay$args =
      _fieldId match {
        case 1 => copy(id = 0)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      w100msDelay$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val id_item = id
        _oprot.writeFieldBegin(IdField)
        _oprot.writeI32(id_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      id: Int = this.id
    ): w100msDelay$args =
      new Immutable(
        id
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[w100msDelay$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => id
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "w100msDelay$args"
  }
  
  object w100msDelay$result extends ThriftStructCodec3[w100msDelay$result] {
    val Struct = new TStruct("w100msDelay_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NotFoundExceptionField = new TField("notFoundException", TType.STRUCT, 1)
    val DisabledExceptionField = new TField("disabledException", TType.STRUCT, 2)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: w100msDelay$result) {
    }
  
    override def encode(_item: w100msDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): w100msDelay$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[SampleStruct] = None,
      notFoundException: Option[NotFoundException] = None,
      disabledException: Option[DisabledException] = None
    ): w100msDelay$result = new Immutable(
      success,
      notFoundException,
      disabledException
    )
  
    def unapply(_item: w100msDelay$result): Option[Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec3[w100msDelay$result] {
      override def encode(_item: w100msDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): w100msDelay$result = {
        var success: SampleStruct = null
        var _got_success = false
        var notFoundException: NotFoundException = null
        var _got_notFoundException = false
        var disabledException: DisabledException = null
        var _got_disabledException = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      SampleStruct.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* notFoundException */
                _field.`type` match {
                  case TType.STRUCT => {
                    notFoundException = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_notFoundException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* disabledException */
                _field.`type` match {
                  case TType.STRUCT => {
                    disabledException = {
                      DisabledException.decode(_iprot)
                    }
                    _got_disabledException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_notFoundException) Some(notFoundException) else None,
          if (_got_disabledException) Some(disabledException) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of w100msDelay$result.  You typically should not need to
     * directly reference this class; instead, use the w100msDelay$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[SampleStruct] = None,
      val notFoundException: Option[NotFoundException] = None,
      val disabledException: Option[DisabledException] = None
    ) extends w100msDelay$result
  
  }
  
  trait w100msDelay$result extends ThriftStruct
    with Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]
    with java.io.Serializable
  {
    import w100msDelay$result._
  
  
    def success: Option[SampleStruct]
    def notFoundException: Option[NotFoundException]
    def disabledException: Option[DisabledException]
  
    def _1 = success
    def _2 = notFoundException
    def _3 = disabledException
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): w100msDelay$result =
      _fieldId match {
        case 0 => copy(success = None)
        case 1 => copy(notFoundException = None)
        case 2 => copy(disabledException = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      w100msDelay$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (notFoundException.isDefined) {
        val notFoundException_item = notFoundException.get
        _oprot.writeFieldBegin(NotFoundExceptionField)
        notFoundException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (disabledException.isDefined) {
        val disabledException_item = disabledException.get
        _oprot.writeFieldBegin(DisabledExceptionField)
        disabledException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[SampleStruct] = this.success, 
      notFoundException: Option[NotFoundException] = this.notFoundException, 
      disabledException: Option[DisabledException] = this.disabledException
    ): w100msDelay$result =
      new Immutable(
        success,
        notFoundException,
        disabledException
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[w100msDelay$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => notFoundException
      case 2 => disabledException
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "w100msDelay$result"
  }
  
  object w200msDelay$args extends ThriftStructCodec3[w200msDelay$args] {
    val Struct = new TStruct("w200msDelay_args")
    val IdField = new TField("id", TType.I32, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: w200msDelay$args) {
    }
  
    override def encode(_item: w200msDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): w200msDelay$args = Immutable.decode(_iprot)
  
    def apply(
      id: Int
    ): w200msDelay$args = new Immutable(
      id
    )
  
    def unapply(_item: w200msDelay$args): Option[Int] = Some(_item.id)
  
    object Immutable extends ThriftStructCodec3[w200msDelay$args] {
      override def encode(_item: w200msDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): w200msDelay$args = {
        var id: Int = 0
        var _got_id = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* id */
                _field.`type` match {
                  case TType.I32 => {
                    id = {
                      _iprot.readI32()
                    }
                    _got_id = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          id
        )
      }
    }
  
    /**
     * The default read-only implementation of w200msDelay$args.  You typically should not need to
     * directly reference this class; instead, use the w200msDelay$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val id: Int
    ) extends w200msDelay$args
  
  }
  
  trait w200msDelay$args extends ThriftStruct
    with Product1[Int]
    with java.io.Serializable
  {
    import w200msDelay$args._
  
  
    def id: Int
  
    def _1 = id
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): w200msDelay$args =
      _fieldId match {
        case 1 => copy(id = 0)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      w200msDelay$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val id_item = id
        _oprot.writeFieldBegin(IdField)
        _oprot.writeI32(id_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      id: Int = this.id
    ): w200msDelay$args =
      new Immutable(
        id
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[w200msDelay$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => id
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "w200msDelay$args"
  }
  
  object w200msDelay$result extends ThriftStructCodec3[w200msDelay$result] {
    val Struct = new TStruct("w200msDelay_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NotFoundExceptionField = new TField("notFoundException", TType.STRUCT, 1)
    val DisabledExceptionField = new TField("disabledException", TType.STRUCT, 2)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: w200msDelay$result) {
    }
  
    override def encode(_item: w200msDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): w200msDelay$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[SampleStruct] = None,
      notFoundException: Option[NotFoundException] = None,
      disabledException: Option[DisabledException] = None
    ): w200msDelay$result = new Immutable(
      success,
      notFoundException,
      disabledException
    )
  
    def unapply(_item: w200msDelay$result): Option[Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec3[w200msDelay$result] {
      override def encode(_item: w200msDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): w200msDelay$result = {
        var success: SampleStruct = null
        var _got_success = false
        var notFoundException: NotFoundException = null
        var _got_notFoundException = false
        var disabledException: DisabledException = null
        var _got_disabledException = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      SampleStruct.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* notFoundException */
                _field.`type` match {
                  case TType.STRUCT => {
                    notFoundException = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_notFoundException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* disabledException */
                _field.`type` match {
                  case TType.STRUCT => {
                    disabledException = {
                      DisabledException.decode(_iprot)
                    }
                    _got_disabledException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_notFoundException) Some(notFoundException) else None,
          if (_got_disabledException) Some(disabledException) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of w200msDelay$result.  You typically should not need to
     * directly reference this class; instead, use the w200msDelay$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[SampleStruct] = None,
      val notFoundException: Option[NotFoundException] = None,
      val disabledException: Option[DisabledException] = None
    ) extends w200msDelay$result
  
  }
  
  trait w200msDelay$result extends ThriftStruct
    with Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]
    with java.io.Serializable
  {
    import w200msDelay$result._
  
  
    def success: Option[SampleStruct]
    def notFoundException: Option[NotFoundException]
    def disabledException: Option[DisabledException]
  
    def _1 = success
    def _2 = notFoundException
    def _3 = disabledException
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): w200msDelay$result =
      _fieldId match {
        case 0 => copy(success = None)
        case 1 => copy(notFoundException = None)
        case 2 => copy(disabledException = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      w200msDelay$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (notFoundException.isDefined) {
        val notFoundException_item = notFoundException.get
        _oprot.writeFieldBegin(NotFoundExceptionField)
        notFoundException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (disabledException.isDefined) {
        val disabledException_item = disabledException.get
        _oprot.writeFieldBegin(DisabledExceptionField)
        disabledException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[SampleStruct] = this.success, 
      notFoundException: Option[NotFoundException] = this.notFoundException, 
      disabledException: Option[DisabledException] = this.disabledException
    ): w200msDelay$result =
      new Immutable(
        success,
        notFoundException,
        disabledException
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[w200msDelay$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => notFoundException
      case 2 => disabledException
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "w200msDelay$result"
  }
  
  object w1sDelay$args extends ThriftStructCodec3[w1sDelay$args] {
    val Struct = new TStruct("w1sDelay_args")
    val IdField = new TField("id", TType.I32, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: w1sDelay$args) {
    }
  
    override def encode(_item: w1sDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): w1sDelay$args = Immutable.decode(_iprot)
  
    def apply(
      id: Int
    ): w1sDelay$args = new Immutable(
      id
    )
  
    def unapply(_item: w1sDelay$args): Option[Int] = Some(_item.id)
  
    object Immutable extends ThriftStructCodec3[w1sDelay$args] {
      override def encode(_item: w1sDelay$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): w1sDelay$args = {
        var id: Int = 0
        var _got_id = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* id */
                _field.`type` match {
                  case TType.I32 => {
                    id = {
                      _iprot.readI32()
                    }
                    _got_id = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          id
        )
      }
    }
  
    /**
     * The default read-only implementation of w1sDelay$args.  You typically should not need to
     * directly reference this class; instead, use the w1sDelay$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val id: Int
    ) extends w1sDelay$args
  
  }
  
  trait w1sDelay$args extends ThriftStruct
    with Product1[Int]
    with java.io.Serializable
  {
    import w1sDelay$args._
  
  
    def id: Int
  
    def _1 = id
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): w1sDelay$args =
      _fieldId match {
        case 1 => copy(id = 0)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      w1sDelay$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val id_item = id
        _oprot.writeFieldBegin(IdField)
        _oprot.writeI32(id_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      id: Int = this.id
    ): w1sDelay$args =
      new Immutable(
        id
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[w1sDelay$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => id
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "w1sDelay$args"
  }
  
  object w1sDelay$result extends ThriftStructCodec3[w1sDelay$result] {
    val Struct = new TStruct("w1sDelay_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NotFoundExceptionField = new TField("notFoundException", TType.STRUCT, 1)
    val DisabledExceptionField = new TField("disabledException", TType.STRUCT, 2)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: w1sDelay$result) {
    }
  
    override def encode(_item: w1sDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): w1sDelay$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[SampleStruct] = None,
      notFoundException: Option[NotFoundException] = None,
      disabledException: Option[DisabledException] = None
    ): w1sDelay$result = new Immutable(
      success,
      notFoundException,
      disabledException
    )
  
    def unapply(_item: w1sDelay$result): Option[Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec3[w1sDelay$result] {
      override def encode(_item: w1sDelay$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): w1sDelay$result = {
        var success: SampleStruct = null
        var _got_success = false
        var notFoundException: NotFoundException = null
        var _got_notFoundException = false
        var disabledException: DisabledException = null
        var _got_disabledException = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      SampleStruct.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* notFoundException */
                _field.`type` match {
                  case TType.STRUCT => {
                    notFoundException = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_notFoundException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* disabledException */
                _field.`type` match {
                  case TType.STRUCT => {
                    disabledException = {
                      DisabledException.decode(_iprot)
                    }
                    _got_disabledException = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_notFoundException) Some(notFoundException) else None,
          if (_got_disabledException) Some(disabledException) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of w1sDelay$result.  You typically should not need to
     * directly reference this class; instead, use the w1sDelay$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[SampleStruct] = None,
      val notFoundException: Option[NotFoundException] = None,
      val disabledException: Option[DisabledException] = None
    ) extends w1sDelay$result
  
  }
  
  trait w1sDelay$result extends ThriftStruct
    with Product3[Option[SampleStruct], Option[NotFoundException], Option[DisabledException]]
    with java.io.Serializable
  {
    import w1sDelay$result._
  
  
    def success: Option[SampleStruct]
    def notFoundException: Option[NotFoundException]
    def disabledException: Option[DisabledException]
  
    def _1 = success
    def _2 = notFoundException
    def _3 = disabledException
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): w1sDelay$result =
      _fieldId match {
        case 0 => copy(success = None)
        case 1 => copy(notFoundException = None)
        case 2 => copy(disabledException = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      w1sDelay$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (notFoundException.isDefined) {
        val notFoundException_item = notFoundException.get
        _oprot.writeFieldBegin(NotFoundExceptionField)
        notFoundException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (disabledException.isDefined) {
        val disabledException_item = disabledException.get
        _oprot.writeFieldBegin(DisabledExceptionField)
        disabledException_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[SampleStruct] = this.success, 
      notFoundException: Option[NotFoundException] = this.notFoundException, 
      disabledException: Option[DisabledException] = this.disabledException
    ): w1sDelay$result =
      new Immutable(
        success,
        notFoundException,
        disabledException
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[w1sDelay$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => notFoundException
      case 2 => disabledException
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "w1sDelay$result"
  }

  import com.twitter.util.Future

  @deprecated("use TestApi[Future]", "3.4.0")
  trait FutureIface extends  TestApi[Future] {
    
    def wNoDelay(id: Int): Future[SampleStruct]
    
    def w100msDelay(id: Int): Future[SampleStruct]
    
    def w200msDelay(id: Int): Future[SampleStruct]
    
    def w1sDelay(id: Int): Future[SampleStruct]
  }

  @deprecated("use TestApi$FinagleClient", "3.4.0")
  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends TestApi$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  @deprecated("use TestApi$FinagleService", "3.4.0")
  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends TestApi$FinagleService(
      iface,
      protocolFactory)
}