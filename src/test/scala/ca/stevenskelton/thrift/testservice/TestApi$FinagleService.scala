/**
 * generated by Scrooge ${project.version}
 */
package ca.stevenskelton.thrift.testservice

import com.twitter.finagle.{Service => FinagleService}
import com.twitter.scrooge.ThriftStruct
import com.twitter.util.Future
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, HashMap => mutable$HashMap}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-09-20T13:33:14.999-0400")
class TestApi$FinagleService(
  iface: TestApi[Future],
  protocolFactory: TProtocolFactory
) extends FinagleService[Array[Byte], Array[Byte]] {
  import TestApi._

  protected val functionMap = new mutable$HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()

  protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
    functionMap(name) = f
  }

  protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
    try {
      val x = new TApplicationException(code, message)
      val memoryBuffer = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(memoryBuffer)

      oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.getTransport().flush()
      Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
    } catch {
      case e: Exception => Future.exception(e)
    }
  }

  protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
    try {
      val memoryBuffer = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(memoryBuffer)

      oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
      result.write(oprot)
      oprot.writeMessageEnd()

      Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
    } catch {
      case e: Exception => Future.exception(e)
    }
  }

  final def apply(request: Array[Byte]): Future[Array[Byte]] = {
    val inputTransport = new TMemoryInputTransport(request)
    val iprot = protocolFactory.getProtocol(inputTransport)

    try {
      val msg = iprot.readMessageBegin()
      functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
        TProtocolUtil.skip(iprot, TType.STRUCT)
        exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
          "Invalid method name: '" + msg.name + "'")
      }
    } catch {
      case e: Exception => Future.exception(e)
    }
  }

  // ---- end boilerplate.

  addFunction("wNoDelay", { (iprot: TProtocol, seqid: Int) =>
    try {
      val args = wNoDelay$args.decode(iprot)
      iprot.readMessageEnd()
      (try {
        iface.wNoDelay(args.id)
      } catch {
        case e: Exception => Future.exception(e)
      }) flatMap { value: SampleStruct =>
        reply("wNoDelay", seqid, wNoDelay$result(success = Some(value)))
      } rescue {
        case e: NotFoundException => {
          reply("wNoDelay", seqid, wNoDelay$result(notFoundException = Some(e)))
        }
        case e: DisabledException => {
          reply("wNoDelay", seqid, wNoDelay$result(disabledException = Some(e)))
        }
        case e => Future.exception(e)
      }
    } catch {
      case e: TProtocolException => {
        iprot.readMessageEnd()
        exception("wNoDelay", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
      }
      case e: Exception => Future.exception(e)
    }
  })
  addFunction("w100msDelay", { (iprot: TProtocol, seqid: Int) =>
    try {
      val args = w100msDelay$args.decode(iprot)
      iprot.readMessageEnd()
      (try {
        iface.w100msDelay(args.id)
      } catch {
        case e: Exception => Future.exception(e)
      }) flatMap { value: SampleStruct =>
        reply("w100msDelay", seqid, w100msDelay$result(success = Some(value)))
      } rescue {
        case e: NotFoundException => {
          reply("w100msDelay", seqid, w100msDelay$result(notFoundException = Some(e)))
        }
        case e: DisabledException => {
          reply("w100msDelay", seqid, w100msDelay$result(disabledException = Some(e)))
        }
        case e => Future.exception(e)
      }
    } catch {
      case e: TProtocolException => {
        iprot.readMessageEnd()
        exception("w100msDelay", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
      }
      case e: Exception => Future.exception(e)
    }
  })
  addFunction("w200msDelay", { (iprot: TProtocol, seqid: Int) =>
    try {
      val args = w200msDelay$args.decode(iprot)
      iprot.readMessageEnd()
      (try {
        iface.w200msDelay(args.id)
      } catch {
        case e: Exception => Future.exception(e)
      }) flatMap { value: SampleStruct =>
        reply("w200msDelay", seqid, w200msDelay$result(success = Some(value)))
      } rescue {
        case e: NotFoundException => {
          reply("w200msDelay", seqid, w200msDelay$result(notFoundException = Some(e)))
        }
        case e: DisabledException => {
          reply("w200msDelay", seqid, w200msDelay$result(disabledException = Some(e)))
        }
        case e => Future.exception(e)
      }
    } catch {
      case e: TProtocolException => {
        iprot.readMessageEnd()
        exception("w200msDelay", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
      }
      case e: Exception => Future.exception(e)
    }
  })
  addFunction("w1sDelay", { (iprot: TProtocol, seqid: Int) =>
    try {
      val args = w1sDelay$args.decode(iprot)
      iprot.readMessageEnd()
      (try {
        iface.w1sDelay(args.id)
      } catch {
        case e: Exception => Future.exception(e)
      }) flatMap { value: SampleStruct =>
        reply("w1sDelay", seqid, w1sDelay$result(success = Some(value)))
      } rescue {
        case e: NotFoundException => {
          reply("w1sDelay", seqid, w1sDelay$result(notFoundException = Some(e)))
        }
        case e: DisabledException => {
          reply("w1sDelay", seqid, w1sDelay$result(disabledException = Some(e)))
        }
        case e => Future.exception(e)
      }
    } catch {
      case e: TProtocolException => {
        iprot.readMessageEnd()
        exception("w1sDelay", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
      }
      case e: Exception => Future.exception(e)
    }
  })
}